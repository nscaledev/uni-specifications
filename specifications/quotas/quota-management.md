# Quota Management

Quotas limit the amount of physical resource an entity can provision.
This has numerous benefits, for example:

* Guaranteeing availability to requests obligations.
* Limit damage when a bad actor tries to exhaust resources.

From a user experience perspective an organization admin can:

* Control the total spend across all projects.
* Control spend across specific projects.
* Display utilization metrics.

## Changelog

- v1.0.0 2025-01-29 (@spjmurray): Initial RFC

## Problem Analysis

### Prior Art

OpenStack takes the approach that everything has a quota.
This, with experience, turns out to be flexible in one respect, but a nightmare in another.

When everything has a quota, quota handling has to be duplicated everywhere, errors need to be properly propagated.
What tends to happen here is errors disappear into the ether and cause mysterious and non-intuitive provisioning errors.
They need to be diagnosed by a super administrator, and then modified by a super administrator.

Care must be taken to improve UX over what is presented here, to reduce the support burden, and improve usability of the product.

### Quotas

Quotas primarily act as a safety measure, and limit what an organization can use:

* Ability to stop a user exhausting all resources in the system (denial of service).
* Ability to minimize the cost when a user can or will not pay (fraud prevention).
  * Google for example won't let you go past 50 Gmail users unless you beg then very nicely and pay up front, or pay them more...
* Ability for an organization to guard against excessive OPEX (cost).
* Ability for the operator to control how big of a slice each organization is allowed (scheduling).

#### Scope

Quotas need to be &mdash; initially &mdash; targeted at what really matters to the business.
In the case of Unikorn, things like groups and projects are ostensibly free, so we should not limit these resources to alleviate the cost of supporting these kinds of quota limits.
What do do care about as a IaaS/PaaS provider are things that cost money to operate:

* Physical servers and networks (e.g. VLANs are limited to 4094 IDs).
* Virtual infrastructure e.g. cluster life-cycle managers.

Rather than defaulting to the narrow-minded and very low level view of Hertz and bytes, we should consider higher level primitives for quota allocation.
Business deals get signed on clusters and servers.

To address the latter point, it's so much easier to put a price on a physical machine, than having to individually add up the cost of every core, every byte of RAM or disk.
Asking for 10 machines &mdash; implicitly with 64 cores, 1TiB RAM and 4 GPUs &mdash; is a lot easier than having to figure out that to supply 40 GPUs, you also need 640 cores and 10TiB of RAM to actually fulfill that request.

![commit](https://img.shields.io/badge/commit-green)

#### Locality

You can consider quotas at different topological localities:

* Global quotas apply across the whole platform.
  * An organization can provision 10 clusters.
* Logical quotas apply to some arbitrary construct.
  * A project can provision 10 clusters.
* Regional quotas apply to a specific region.
  * What would be useful is an API that shows how much resource is available in the region and whether a request to create a cluster of N servers can be facilitated.

Obviously with each step down the hierarchy, things get more complex to implement, configure, test, and maintain, so we should place the onus on simplicity and reliability above all else.

![partial](https://img.shields.io/badge/partial-orange)

#### Overcommit

If we take the na&iuml;ve view that user A has a quota that takes up 50% of the system, and user B the other 50%, then you cannot schedule any more users on to your finite hardware footprint.
In real life, it's likely that that quota will be under utilized, and unused, essentially burning electricity.
This is especially prevalent with features such as autoscaling that grow and shrink to match the requirements of the workload.
The goal here is to maximize the revenue generated by your hardware.

![nice to have](https://img.shields.io/badge/nice_to_have-red)

### Reservations

An organization may want guaranteed access to 100 machines, rather than a soft constraint that prevents the user from sending too much.
At present we have a coarse grain method of providing this with private regions.

![nice to have](https://img.shields.io/badge/nice_to_have-red)

### Scheduling

This leans more into the usability side of things.
Consider where you have a workload that you need to run, you try a region, that fails because it's out of resource.
Wouldn't it be far better to let the system place it where it can be scheduled?


Going back to earlier points on logical regions, wouldn't is be okay to just place it wherever it fits based on some optional scheduling hints e.g. cost?

> [!NOTE]
> Anecdotally it's like a pub when you ask for "a lager", they will always serve you the most expensive premium brand unless you place some constraints on them...

![nice to have](https://img.shields.io/badge/nice_to_have-red)

From a more simplistic view, and going back to an earlier point, it would be nice for the creation or upgrade process to ask "does this fit?" e.g. with a reservation, and provide feedback to user rather than raising a hidden error further down the stack.

There are two approaches here:

* Is there enough resource to fulfill the entire request.
  * This does not handle autoscaling, which could fail during a peak period.
  * It could be improved with OpenStack Blazar, but this is very platform specific, and potentially wasteful going forward.
    Additionally it's yet another dependency that someone has to maintain.
* How much resource do I have overall?
  * For most clouds this will be "infinite".
  * For OpenStack we can poll the physical machines.
    While this is great for ironic nodes, it's less so for virtual machines.

For now I'm going to rule this out as it's a hard problem, and one that can be solved by the platform teams monitoring utilization and managing the cluster scaling proactively.

![nice to have](https://img.shields.io/badge/nice_to_have-red)

## Minimum Viable Product

For all of the above discussion we should aim to deliver the following:

* An organization has a hard quota associated with it.
  * This allows the platform operators to constrain cluster (e.g. VLAN), and server use across the platform, this prevents unfair use and _mitigates_ resource exhaustion.
  * Customers wanting more resource can apply via the support channel, this may lead to a commercial discussion or one to do with procurement.
* Quotas must support:
  * Clusters.
  * Servers.
  * Arbitrary 3rd party resources (e.g. SaaS offerings that don't fit into existing quotas).

## Design Considerations

If we consider quotas are associated with organizations, and looking forward could also be allocated to specific projects, it seems logical that this should live in the Identity service.
On the other hand, there is nothing tying this specifically to the Identity service either, and it could be implemented as an independent micro service.

If we choose the former, then steps MUST be taken to avoid coupling and allow transition to the latter.

### Data Structures

Either way, quotas should be implemented as a separate CRD, it should reside in the organization's namespace so as to be garbage collected on organization deletion.

Kubernetes and compute services will need APIs that atomically (etcd compare & swap handles this) allocate and deallocate resources.
The Kubernetes service specifically requires committed use, and opportunistic use (autoscaling).

Per-resource allocations should be separate resources that can be indexed by ID and that can be stashed away as as an annotation on the resource, in a similar way to how cloud identities are managed today.

### Data Management

An organization will need a default quota set on creation, and upgrading to a release with quotas will require tooling to create this retrospectively.

### APIs

The UI will need APIs to read quotas, and how much has been allocated for display on a dashboard.

Management functions will need APIs to update the quotas and allocations.
The API must be constrained to:

* Not allow quota limits to be reduced so that they conflict with existing allocations, thus causing a logical inconsistency.
* Not allow allocations that conflict with quota limits.

APIs will need to be designed so organization administrators and platform administrators get the correct permissions.

## Specification

### `/api/v1/organizations/{organizationID}/quotas`

This API should be readable by everyone and is used for summaries, visualization and checking whether a creation request can be fulfilled by a client.

> [!NOTE]
> A future extension point could be the `/api/v1/organizations/{organizationID}/projects/{projectID}/quotas` route.
> We'd then need to make a top-level distinction about resources that are free-for-all and those that are allocated to specific projects.

#### `GET`

```json
{
    "capacity": [
        {
            "type": "clusters",
            "amount": 5
        },
        {
            "type": "servers",
            "amount": 10
        }
    ],
    "free": [
        {
            "type": "clusters",
            "amount": 4
        },
        {
            "type": "servers",
            "amount": 2
        }
    ],
    "allocated": [
        {
            "type": "clusters",
            "amount": 1,
            "committed": 1,
            "reserved": 0
        },
        {
            "type": "servers",
            "amount": 8,
            "committed": 3,
            "reserved": 5
        }
    ]
}
```

> [!NOTE]
> `committed` are things that always exist, `reserved` are for things like cluster autoscaling.

#### `PUT`

```json
{
    "capacity": [
        {
            "type": "clusters",
            "amount": 5
        },
        {
            "type": "servers",
            "amount": 10
        }
    ]
}
```

#### RBAC

| Actor | Permissions |
| --- | --- |
| platform-administrator | read,update |
| administrator | read |
| user | read |
| reader | read |

### `/api/v1/organizations/{organizationID}/allocations`

This API is a detailed view for used by anyone that crosses all projects and can be used to finger point at expensive organizational units.
It's also used to create individual allocations.

#### `GET`

```json
[
    {
        "metadata": {
            "id": "f6fbafc9-d621-4a44-9196-cdf2be165e72",
            "name": "unused",
            "organizationID": "da519676-8e78-4dcb-94dd-507aa0eab23e",
            "projectID": "c53efec8-da76-4d54-9565-1c6daf755926",
            "creationTimestamp": "Wed 29 Jan 13:56:10 GMT 2025",
            "createdBy": "unikorn-kubernetes",
        },
        "spec": {
            "kind": "kubernetescluster",
            "id": "d6beb0dd-209b-40bf-aa03-bef974f33121"
            "resources": [
                {
                    "type": "clusters",
                    "amount": 1,
                    "committed": 1,
                    "reserved": 0
                },
                {
                    "type": "servers",
                    "amount": 8,
                    "commited": 3,
                    "reserved": 5
                },
            ]
        }
    }
]
```

> [!NOTE]
> Allocations will be filtered by the API based on project ACLs.
> This can be filtered by project ID and reduced to a per-project overall utilization view.

#### POST

```json
[
    {
        "metadata": {
            "id": "f6fbafc9-d621-4a44-9196-cdf2be165e72",
            "name": "unused",
        },
        "spec": {
            "kind": "kubernetescluster",
            "id": "d6beb0dd-209b-40bf-aa03-bef974f33121"
            "resources": [
                {
                    "type": "clusters",
                    "committed": 1,
                    "reserved": 0
                },
                {
                    "type": "servers",
                    "commited": 3,
                    "reserved": 5
                },
            ]
        }
    }
]
```

> [!NOTE]
> The API deliberately doesn't expose and `amount` field as seen in the GET, as you could conceivably balls up the simple addition and lead to inconsistency.

#### RBAC

| Actor | Permissions |
| --- | --- |
| platform-administrator | create,read |
| quota-manager-service | create |
| administrator | read |
| user | read |
| reader | read |

### `/api/v1/organizations/{organizationID}/projects/{projectID}/allocations/{allocationID}`

This API is used by the Kubernetes and Compute (etc) services to manage allocations.
The API server is responsible for ensuring that the aggregation of all allocations in the organization do not exceed the quota limits for the organization.

#### `GET`

```json
{               
    "metadata": {
        "id": "f6fbafc9-d621-4a44-9196-cdf2be165e72",
        "name": "unused",
        "organizationID": "da519676-8e78-4dcb-94dd-507aa0eab23e",
        "projectID": "c53efec8-da76-4d54-9565-1c6daf755926",
        "creationTimestamp": "Wed 29 Jan 13:56:10 GMT 2025",
        "createdBy": "unikorn-kubernetes",
    },
    "spec": {
        "kind": "kubernetescluster",
        "id": "d6beb0dd-209b-40bf-aa03-bef974f33121"
        "resources": [
            {
                "type": "clusters",
                "amount": 1,
                "committed": 1,
                "reserved": 0
            },
            {
                "type": "servers",
                "amount": 8,
                "commited": 3,
                "reserved": 5
            },
        ]
    }
}
```

#### `PUT`

```json
{
    "metadata": {
        "id": "f6fbafc9-d621-4a44-9196-cdf2be165e72",
        "name": "unused",
    },
    "spec": {
        "resources": [
            {
                "type": "clusters",
                "committed": 1,
                "reserved": 0
            },
            {
                "type": "servers",
                "commited": 3,
                "reserved": 12
            },
        ]
    }
}
```

> [!NOTE]
> Once set the resource kind and ID are immutable.
> It makes no sense to allow that as in Kubernetes it would have been deleted!

#### `DELETE`

_No body_

> [!NOTE]
> The API deliberately doesn't expose and `amount` field as seen in the GET, as you could conceivably balls up the simple addition and lead to inconsistency.

#### RBAC

| Actor | Permissions |
| --- | --- | 
| platform-administrator | read,update,delete |
| quota-manager-service | read,update,delete |
| administrator | read |
| user | read |
| reader | read |
